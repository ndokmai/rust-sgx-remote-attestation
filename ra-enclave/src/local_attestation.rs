// Modified from https://gist.github.com/Vinc0682/10c074202c995e4f87b4edf278ec4cae
use crate::error::LocalAttestationError;
use sgx_crypto::cmac::Cmac;
use sgx_isa::{Keyname, Keyrequest, Report, Targetinfo};

/// Fetches the own target info and puts it into a byte-vector.
pub fn get_own_targetinfo() -> Vec<u8> {
    let ti = Targetinfo::from(Report::for_self());
    let result: &[u8] = ti.as_ref();
    result.to_vec().clone()
}

/// Tries to create a report for the given target and puts it into a byte-vector.
/// Returns None if the target is invalid, returns the report otherwise.
pub fn locally_attest(target: &Vec<u8>, data: &[u8; 64]) -> Option<Vec<u8>> {
    let ti = Targetinfo::try_copy_from(&target[..])?;
    let report = Report::for_target(&ti, data);
    let report: &[u8] = report.as_ref();
    Some(report.to_vec().clone())
}

/// Verifies a report created by locally_attest (or any other report generated by an enclave).
/// Returns true if the report is correctly formed and has been generated on the same machine/CPU
/// as the current enclave.
pub fn verify_local_attest(report: &[u8]) -> Result<(), LocalAttestationError> {
    if report.len() != Report::UNPADDED_SIZE {
        return Err(LocalAttestationError::IncorrectReportLength);
    }
    // Can unwrap since the length is verified
    let report = Report::try_copy_from(report).unwrap();
    verify_report(&report)
}

/// Verifies the given report locally, a.k.a. returns true if the Report was created in an enclave
/// on the same CPU.
pub fn verify_report(report: &Report) -> Result<(), LocalAttestationError> {
    // Derive the report key.
    let request = Keyrequest {
        keyname: Keyname::Report as _,
        keyid: report.keyid.clone(),
        ..Default::default()
    };
    // Maybe result false instead of panicking, but the specs
    // ( https://software.intel.com/en-us/articles/intel-sdm Volume 3C, Chapter 40-4 )
    // state that EGETKEY should have a problem with this parameters, so if it doesn't work
    // there might be a deeper issue making a panic appropriate.
    let key = request.egetkey().expect("Can't derive report key");

    // Extract the data that is signed.
    let report_data: &[u8] = report.as_ref();
    let mut mac_data = &report_data[0..Report::UNPADDED_SIZE - 48];

    // Compute and verify the mac on the data.
    let mut mac = Cmac::new(&key)?;
    mac.verify(&mut mac_data, &report.mac)
        .map_err(|_| LocalAttestationError::IntegrityError)
}
